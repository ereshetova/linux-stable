=====================
KSPP: HARDENED_ATOMIC
=====================

Risks/Vulnerabilities Addressed
===============================

The Linux Kernel Self Protection Project (KSPP) was created with a mandate
to eliminate classes of kernel bugs. The class of vulnerabilities addressed
by HARDENED_ATOMIC is known as use-after-free vulnerabilities.

HARDENED_ATOMIC is based off of work done by the PaX Team [1].  The feature
on which HARDENED_ATOMIC is based is called PAX_REFCOUNT in the original 
PaX patch.

Use-after-free Vulnerabilities
------------------------------
Use-after-free vulnerabilities are aptly named: they are classes of bugs in
which an attacker is able to gain control of a piece of memory after it has
already been freed and use this memory for nefarious purposes: introducing
malicious code into the address space of an existing process, redirecting
the flow of execution, etc.

While use-after-free vulnerabilities can arise in a variety of situations, 
the use case addressed by HARDENED_ATOMIC is that of referenced counted 
objects.  The kernel can only safely free these objects when all existing 
users of these objects are finished using them.  This necessitates the 
introduction of some sort of accounting system to keep track of current
users of kernel objects.  Reference counters and get()/put() APIs are the 
means typically chosen to do this: calls to get() increment the reference
counter, put() decrments it.  When the value of the reference counter
becomes some sentinel (typically 0), the kernel can safely free the counted
object.  

Problems arise when the reference counter gets overflowed.  If the reference
counter is represented with a signed integer type, overflowing the reference
counter causes it to go from INT_MAX to INT_MIN, then approach 0.  Depending
on the logic, the transition to INT_MIN may be enough to trigger the bug,
but when the reference counter becomes 0, the kernel will free the
underlying object guarded by the reference counter while it still has valid
users.


HARDENED_ATOMIC Design
======================

HARDENED_ATOMIC provides its protections by modifying the data type used in
the Linux kernel to implement reference counters: atomic_t. atomic_t is a
type that contains an integer type, used for counting. HARDENED_ATOMIC
modifies atomic_t and its associated API so that the integer type contained
inside of atomic_t cannot be overflowed.

A key point to remember about HARDENED_ATOMIC is that, once enabled, it 
protects all users of atomic_t without any additional code changes. The
protection provided by HARDENED_ATOMIC is not “opt-in”: since atomic_t is so
widely misused, it must be protected as-is. HARDENED_ATOMIC protects all
users of atomic_t and atomic_long_t against overflow. New users wishing to
use atomic types, but not needing protection against overflows, should use
the new types introduced by this series: atomic_wrap_t and
atomic_long_wrap_t.

Detect/Mitigate
---------------
The mechanism of HARDENED_ATOMIC can be viewed as a bipartite process:
detection of an overflow and mitigating the effects of the overflow, either
by not performing or performing, then reversing, the operation that caused
the overflow.

Overflow detection is architecture-specific. Details of the approach used to
detect overflows on each architecture can be found in the PAX_REFCOUNT
documentation. [1]

Once an overflow has been detected, HARDENED_ATOMIC mitigates the overflow
by either reverting the operation or simply not writing the result of the
operation to memory.


HARDENED_ATOMIC Implementation
==============================

As mentioned above, HARDENED_ATOMIC modifies the atomic_t API to provide its
protections. Following is a description of the functions that have been
modified.

Benchmarks show that no measurable performance difference occurs when
HARDENED_ATOMIC is enabled.

First, the type atomic_wrap_t needs to be defined for those kernel users who
want an atomic type that may be allowed to overflow/wrap (e.g. statistical
counters). Otherwise, the built-in protections (and associated costs) for
atomic_t would erroneously apply to these non-reference counter users of
atomic_t:

  * include/linux/types.h: define atomic_wrap_t and atomic64_wrap_t

Next, we define the mechanism for reporting an overflow of a protected 
atomic type:

  * kernel/panic.c: void hardened_atomic_overflow(struct pt_regs)

The following functions are an extension of the atomic_t API, supporting
this new “wrappable” type:

  * static inline int atomic_read_wrap()
  * static inline void atomic_set_wrap()
  * static inline void atomic_inc_wrap()
  * static inline void atomic_dec_wrap()
  * static inline void atomic_add_wrap()
  * static inline long atomic_inc_return_wrap()

Departures from Original PaX Implementation
-------------------------------------------
While HARDENED_ATOMIC is based largely upon the work done by PaX in their
original PAX_REFCOUNT patchset, HARDENED_ATOMIC does in fact have a few
minor differences. We will be posting them here as final decisions are made
regarding how certain core protections are implemented.

x86 Race Condition
------------------
In the original implementation of PAX_REFCOUNT, a known race condition
exists when performing atomic add operations.  The crux of the problem lies
in the fact that, on x86, there is no way to know a priori whether a 
prospective atomic operation will result in an overflow.  To detect an
overflow, PAX_REFCOUNT had to perform an operation then check if the 
operation caused an overflow.  

Therefore, there exists a set of conditions in which, given the correct
timing of threads, an overflowed counter could be visible to a processor.
If multiple threads execute in such a way so that one thread overflows the
counter with an addition operation, while a second thread executes another
addition operation on the same counter before the first thread is able to
revert the previously executed addition operation (by executing a
subtraction operation of the same (or greater) magnitude), the counter will
have been incremented to a value greater than INT_MAX. At this point, the
protection provided by PAX_REFCOUNT has been bypassed, as further increments
to the counter will not be detected by the processor’s overflow detection
mechanism.

Note that only SMP systems are vulnerable to this race condition.

The likelihood of an attacker being able to exploit this race was 
sufficiently insignificant such that fixing the race would be
counterproductive. 

[1] https://pax.grsecurity.net
[2] https://forums.grsecurity.net/viewtopic.php?f=7&t=4173
